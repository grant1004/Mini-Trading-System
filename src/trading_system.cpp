#include "trading_system.h"
#include <iostream>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <thread>
   
    



TradingSystem::TradingSystem(int port) 
    : serverPort_(port) {
    std::cout << "üåê Trading System created on port " << port << std::endl;
}

TradingSystem:: ~TradingSystem(){
    stop();
    std::cout << "üßπ Trading System destroyed" << std::endl;
}

// ===== Á≥ªÁµ±ÁîüÂëΩÈÄ±Êúü =====

bool TradingSystem::start() {
    std::cout << "üöÄ Starting Trading System on port " << serverPort_ << std::endl;
    
    // 1. ÂàùÂßãÂåñÊíÆÂêàÂºïÊìé
    if (!initializeMatchingEngine()) {
        std::cerr << "‚ùå Failed to initialize MatchingEngine" << std::endl;
        return false;
    }
    
    // 2. ÂàùÂßãÂåñ TCP ÊúçÂãôÂô®
    if (!initializeTcpServer()) {
        std::cerr << "‚ùå Failed to initialize TCP Server" << std::endl;
        return false;
    }
    
    running_ = true;
    std::cout << "‚úÖ Trading System started successfully!" << std::endl;
    std::cout << "üìä Waiting for client connections..." << std::endl;
    return true;
}

void TradingSystem::stop() {
    if (!running_.load()) {
        return;
    }
    
    std::cout << "üõë Stopping Trading System..." << std::endl;
    running_ = false;
    
    // 1. ÂÅúÊ≠¢ TCP ÊúçÂãôÂô® (‰∏çÂÜçÊé•ÂèóÊñ∞ÈÄ£Á∑ö)
    if (tcpServer_) {
        tcpServer_->stop();
    }
    
    // 2. Ê∏ÖÁêÜÊâÄÊúâÂÆ¢Êà∂Á´Ø Session
    cleanupResources();
    
    // 3. ÂÅúÊ≠¢ÊíÆÂêàÂºïÊìé
    if (matchingEngine_) {
        matchingEngine_->stop();
    }
    
    std::cout << "‚úÖ Trading System stopped" << std::endl;
}

// ===== ÂàùÂßãÂåñÊñπÊ≥ï =====

bool TradingSystem::initializeMatchingEngine() {
    try {
        matchingEngine_ = std::make_unique<MatchingEngine>();
        
        // Ë®≠ÂÆöÂõûË™øÂáΩÂºè
        matchingEngine_->setExecutionCallback(
            [this](const ExecutionReportPtr& report) {
                handleExecutionReport(report);
            }
        );
        
        matchingEngine_->setErrorCallback(
            [this](const std::string& error) {
                handleMatchingEngineError(error);
            }
        );
        
        // Ë®≠ÂÆöÈ¢®Èö™ÂèÉÊï∏
        matchingEngine_->setMaxOrderPrice(10000.0);
        matchingEngine_->setMaxOrderQuantity(1000000);
        matchingEngine_->enableRiskCheck(true);
        matchingEngine_->enableMarketData(true);
        
        // ÂïüÂãïÊíÆÂêàÂºïÊìé
        return matchingEngine_->start();
        
    } catch (const std::exception& e) {
        std::cerr << "MatchingEngine initialization error: " << e.what() << std::endl;
        return false;
    }
}


bool TradingSystem::initializeTcpServer() {
    try {
        std::cout << "üåê ÂàùÂßãÂåñÂ¢ûÂº∑Áâà TCP ÊúçÂãôÂô®..." << std::endl;
        
        // Âª∫Á´ãÂ¢ûÂº∑Áâà TCP ÊúçÂãôÂô®
        tcpServer_ = std::make_unique<TCPServer>(serverPort_);
        
        // üîÑ ‰øÆÊîπÔºöÈÄ£Á∑öÂõûË™øÂèÉÊï∏ÊîπÁÇ∫ SOCKET
        tcpServer_->setConnectionCallback([this](SOCKET clientSocket) {  // ÊîπÁÇ∫ SOCKET
            std::cout << "üéâ Êñ∞ÂÆ¢Êà∂Á´ØÈÄ£Á∑ö: " << clientSocket << std::endl;
            handleNewConnection(clientSocket);
        });
        
        // üîÑ ‰øÆÊîπÔºöË®äÊÅØÂõûË™øÂèÉÊï∏ÊîπÁÇ∫ SOCKET
        tcpServer_->setMessageCallback([this](SOCKET clientSocket, const std::string& message) {  // ÊîπÁÇ∫ SOCKET
            std::cout << "üì® Êî∂Âà∞ÂÆ¢Êà∂Á´Ø " << clientSocket << " Ë®äÊÅØ: " << message << std::endl;
            handleClientMessage(clientSocket, message);
        });
        
        // üîÑ ‰øÆÊîπÔºöÊñ∑Á∑öÂõûË™øÂèÉÊï∏ÊîπÁÇ∫ SOCKET
        tcpServer_->setDisconnectionCallback([this](SOCKET clientSocket) {  // ÊîπÁÇ∫ SOCKET
            std::cout << "üì¥ ÂÆ¢Êà∂Á´ØÊñ∑Á∑ö: " << clientSocket << std::endl;
            handleClientDisconnection(clientSocket);
        });
        
        // ÈåØË™§ÂõûË™ø‰øùÊåÅ‰∏çËÆä
        tcpServer_->setErrorCallback([this](const std::string& error) {
            std::cerr << "üö® TCP ÊúçÂãôÂô®ÈåØË™§: " << error << std::endl;
        });
        
        // ÂïüÂãïÊúçÂãôÂô®
        bool success = tcpServer_->start();
        if (success) {
            std::cout << "‚úÖ TCP ÊúçÂãôÂô®ÂïüÂãïÊàêÂäüÔºåÁõ£ËÅΩ port " << serverPort_ << std::endl;
        } else {
            std::cerr << "‚ùå TCP ÊúçÂãôÂô®ÂïüÂãïÂ§±Êïó" << std::endl;
        }
        
        return success;
        
    } catch (const std::exception& e) {
        std::cerr << "TCP Server initialization error: " << e.what() << std::endl;
        return false;
    }
}


// ===== TCP ÈÄ£Á∑öËôïÁêÜ =====
void TradingSystem::handleNewConnection(SOCKET clientSocket) {
    std::cout << "üìû New client connected: " << clientSocket << std::endl;
    
    try {
        // Êõ¥Êñ∞Áµ±Ë®à
        totalConnections_.fetch_add(1);
        
        // Âª∫Á´ã FIX Session
        std::string senderCompID = "SERVER";
        std::string targetCompID = "CLIENT_" + std::to_string(static_cast<int64_t>(clientSocket));
        
        auto fixSession = std::make_unique<FixSession>(senderCompID, targetCompID);
        
        // Ë®≠ÂÆö FIX Session ÂõûË™ø
        fixSession->setApplicationMessageHandler(
            [this, clientSocket](const FixMessage& msg) {
                try {
                    handleFixApplicationMessage(clientSocket, msg);
                } catch (const std::exception& e) {
                    std::cerr << "‚ùå Error in application message handler: " << e.what() << std::endl;
                }
            }
        );
        
        fixSession->setErrorHandler(
            [this, clientSocket](const std::string& error) {
                std::cerr << "üö® Session " << clientSocket << " error: " << error << std::endl;
                // ÂèØ‰ª•ËÄÉÊÖÆÂú®Âö¥ÈáçÈåØË™§ÊôÇÊñ∑ÈñãÈÄ£Á∑ö
            }
        );
        
        // Ë®≠ÂÆöÁôºÈÄÅÂáΩÂºè
        fixSession->setSendFunction(
            [this, clientSocket](const std::string& message) -> bool {
                if (!tcpServer_ || !tcpServer_->isRunning()) {
                    std::cerr << "‚ùå TCP Server not available" << std::endl;
                    return false;
                }
                
                try {
                    return tcpServer_->sendMessage(clientSocket, message);
                } catch (const std::exception& e) {
                    std::cerr << "‚ùå Send error: " << e.what() << std::endl;
                    return false;
                }
            }
        );
        
        // Ë®≠ÂÆöÂøÉË∑≥ÈñìÈöî
        fixSession->setHeartbeatInterval(std::chrono::seconds(30));
        
        // Âª∫Á´ã‰∏¶‰øùÂ≠ò Session
        std::string clientInfo = "Socket_" + std::to_string(static_cast<int64_t>(clientSocket));
        
        {
            std::lock_guard<std::mutex> lock(sessionsMutex_);
            sessions_[clientSocket] = std::make_unique<ClientSession>(
                std::move(fixSession), 
                clientInfo
            );
        }
        
        std::cout << "‚úÖ FIX Session created for client " << clientSocket 
                  << " (" << senderCompID << " -> " << targetCompID << ")" << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "‚ùå Error handling new connection " << clientSocket 
                  << ": " << e.what() << std::endl;
        
        // Ê∏ÖÁêÜÂèØËÉΩÂ∑≤Âª∫Á´ãÁöÑË≥áÊ∫ê
        cleanupSession(clientSocket);
    }
}


void TradingSystem::handleClientDisconnection(SOCKET clientSocket) {  // ÂèÉÊï∏È°ûÂûãÊîπÁÇ∫ SOCKET
    std::cout << "üì¥ Client disconnected: " << clientSocket << std::endl;
    cleanupSession(clientSocket);
}

void TradingSystem::handleClientMessage(SOCKET clientSocket, const std::string& rawMessage) {
    std::lock_guard<std::mutex> lock(sessionsMutex_);
    
    auto it = sessions_.find(clientSocket);
    if (it == sessions_.end()) {
        std::cerr << "No session found for client: " << clientSocket << std::endl;
        return;
    }
    
    // ‰∫§Áµ¶ FIX Session ËôïÁêÜ
    try {
        it->second->fixSession->processIncomingMessage(rawMessage);
    } catch (const std::exception& e) {
        std::cerr << "Error processing message from " << clientSocket << ": " << e.what() << std::endl;
    }
}

// ===== FIX Ë®äÊÅØËôïÁêÜ =====

void TradingSystem::handleFixApplicationMessage(SOCKET clientSocket, const FixMessage& fixMsg) {
    auto msgType = fixMsg.getMsgType();
    if (!msgType) {
        std::cerr << "Invalid message type from client " << clientSocket << std::endl;
        return;
    }
    
    std::cout << "üì® Received FIX message type '" << *msgType << "' from client " << clientSocket << std::endl;
    
    switch (*msgType) {
        case FixMessage::NewOrderSingle:
            handleNewOrderSingle(clientSocket, fixMsg);
            break;
            
        case FixMessage::OrderCancelRequest:
            handleOrderCancelRequest(clientSocket, fixMsg);
            break;
            
        default:
            std::cerr << "Unsupported message type: " << *msgType << std::endl;
            break;
    }
}

void TradingSystem::handleNewOrderSingle(SOCKET clientSocket, const FixMessage& fixMsg) {
    try {
        std::cout << "üìã Processing New Order Single from client " << clientSocket << std::endl;
        
        // ËΩâÊèõ FIX Ë®äÊÅØÁÇ∫ Order Áâ©‰ª∂
        auto order = convertFixToOrder(fixMsg, clientSocket);
        
        // Êèê‰∫§Âà∞ÊíÆÂêàÂºïÊìé
        if (matchingEngine_->submitOrder(order)) {
            std::cout << "‚úÖ Order " << order->getOrderId() << " submitted to MatchingEngine" << std::endl;
        } else {
            std::cout << "‚ùå Failed to submit order to MatchingEngine" << std::endl;
            sendOrderReject(clientSocket, fixMsg, "MatchingEngine unavailable");
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error processing new order: " << e.what() << std::endl;
        sendOrderReject(clientSocket, fixMsg, e.what());
    }
}

void TradingSystem::handleOrderCancelRequest(SOCKET clientSocket, const FixMessage& fixMsg) {
    try {
        std::cout << "‚ùå Processing Order Cancel Request from client " << clientSocket << std::endl;
        
        std::string origClOrdId = fixMsg.getField(41);  // OrigClOrdID
        
        // ÊâæÂà∞Â∞çÊáâÁöÑ OrderID
        OrderID targetOrderId = 0;
        {
            std::lock_guard<std::mutex> lock(mappingsMutex_);
            for (const auto& pair : orderMappings_) {
                if (pair.second.clientSocket == clientSocket && 
                    pair.second.clOrdId == origClOrdId) {
                    targetOrderId = pair.first;
                    break;
                }
            }
        }
        
        if (targetOrderId == 0) {
            sendOrderReject(clientSocket, fixMsg, "Original order not found");
            return;
        }
        
        // Êèê‰∫§ÂèñÊ∂àË´ãÊ±Ç
        if (matchingEngine_->cancelOrder(targetOrderId, "Client requested")) {
            std::cout << "‚úÖ Cancel request for Order " << targetOrderId << " submitted" << std::endl;
        } else {
            sendOrderReject(clientSocket, fixMsg, "Failed to submit cancel request");
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error processing cancel request: " << e.what() << std::endl;
        sendOrderReject(clientSocket, fixMsg, e.what());
    }
}

// ===== ÊíÆÂêàÂºïÊìéÂõûË™ø =====

void TradingSystem::handleExecutionReport(const ExecutionReportPtr& report) {
    std::cout << "üìä Received ExecutionReport: " << report->toString() << std::endl;
    
    try {
        // ÊâæÂà∞Â∞çÊáâÁöÑÂÆ¢Êà∂Á´Ø
        OrderMapping mapping{0, "", ""};
        {
            std::lock_guard<std::mutex> lock(mappingsMutex_);
            auto it = orderMappings_.find(report->orderId);
            if (it == orderMappings_.end()) {
                std::cerr << "No mapping found for OrderID: " << report->orderId << std::endl;
                return;
            }
            mapping = it->second;
            
            // Â¶ÇÊûúË®ÇÂñÆÂ∑≤ÂÆåÊàêÔºåÊ∏ÖÁêÜÊò†Â∞Ñ
            if (report->status == OrderStatus::Filled || 
                report->status == OrderStatus::Cancelled ||
                report->status == OrderStatus::Rejected) {
                orderMappings_.erase(it);
            }
        }
        
        // ËΩâÊèõÁÇ∫ FIX ExecutionReport
        auto fixReport = convertReportToFix(report);
        
        // Ë®≠ÂÆöÂÆ¢Êà∂Á´ØÁâπÂÆöÁöÑÊ¨Ñ‰Ωç
        fixReport.setField(11, mapping.clOrdId);  // ClOrdID
        
        // ÁôºÈÄÅÁµ¶Â∞çÊáâÁöÑÂÆ¢Êà∂Á´Ø
        if (!sendFixMessage(mapping.clientSocket, fixReport)) {
            std::cerr << "Failed to send ExecutionReport to client " << mapping.clientSocket << std::endl;
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error handling execution report: " << e.what() << std::endl;
    }
}

void TradingSystem::handleMatchingEngineError(const std::string& error) {
    std::cerr << "üö® MatchingEngine Error: " << error << std::endl;
    // ÈÄôË£°ÂèØ‰ª•Âä†ÂÖ•Êõ¥Â§öÁöÑÈåØË™§ËôïÁêÜÈÇèËºØÔºå‰æãÂ¶ÇÔºö
    // - Ë®òÈåÑÂà∞Êó•Ë™åÊñá‰ª∂
    // - ÁôºÈÄÅÁ≥ªÁµ±Ë≠¶Â†±
    // - Áµ±Ë®àÈåØË™§Áéá
}

// ===== Ë®äÊÅØËΩâÊèõ =====

std::shared_ptr<Order> TradingSystem::convertFixToOrder(const FixMessage& fixMsg, SOCKET clientSocket) {
    // ÊèêÂèñ FIX Ê¨Ñ‰Ωç
    std::string clOrdId = fixMsg.getField(11);      // ClOrdID
    std::string symbol = fixMsg.getField(55);       // Symbol
    std::string sideStr = fixMsg.getField(54);      // Side
    std::string qtyStr = fixMsg.getField(38);       // OrderQty
    std::string typeStr = fixMsg.getField(40);      // OrdType
    std::string priceStr = fixMsg.getField(44);     // Price (ÈôêÂÉπÂñÆÊâçÊúâ)
    
    // È©óË≠âÂøÖË¶ÅÊ¨Ñ‰Ωç
    if (clOrdId.empty() || symbol.empty() || sideStr.empty() || qtyStr.empty() || typeStr.empty()) {
        throw std::invalid_argument("Missing required FIX fields");
    }
    
    // ËΩâÊèõÁÇ∫Ê•≠ÂãôÁâ©‰ª∂
    OrderID orderId = generateOrderId();
    Side side = parseFixSide(sideStr);
    OrderType orderType = parseFixOrderType(typeStr);
    Quantity quantity = std::stoull(qtyStr);
    Price price = (orderType == OrderType::Market) ? 0.0 : std::stod(priceStr);
    
    // Âª∫Á´ã Order Áâ©‰ª∂
    auto order = std::make_shared<Order>(
        orderId,
        std::to_string(clientSocket), // ‰ΩøÁî® clientSocket ‰ΩúÁÇ∫ ClientID
        symbol,
        side,
        orderType,
        price,
        quantity
    );
    
    // ‰øùÂ≠òÊò†Â∞ÑÈóú‰øÇ
    {
        std::lock_guard<std::mutex> lock(mappingsMutex_);
        orderMappings_.emplace(orderId, OrderMapping(clientSocket, clOrdId, symbol));
    }
    
    std::cout << "üîÑ Converted FIX ‚Üí Order: " << order->toString() << std::endl;
    return order;
}

FixMessage TradingSystem::convertReportToFix(const ExecutionReportPtr& report) {
    // Âª∫Á´ãÂü∫Êú¨ÁöÑ ExecutionReport
    FixMessage fixMsg('8');  // MsgType = ExecutionReport
    
    // Ë®≠ÂÆöÊ®ôÊ∫ñÊ¨Ñ‰Ωç
    fixMsg.setField(17, generateExecId());                    // ExecID
    fixMsg.setField(150, std::string(1, getFixExecType(report->status))); // ExecType
    fixMsg.setField(39, std::string(1, getFixOrdStatus(report->status)));  // OrdStatus
    fixMsg.setField(55, report->symbol);                      // Symbol
    fixMsg.setField(54, std::string(1, (report->side == Side::Buy) ? '1' : '2')); // Side
    fixMsg.setField(38, std::to_string(report->originalQuantity)); // OrderQty
    fixMsg.setField(151, std::to_string(report->remainingQuantity)); // LeavesQty
    fixMsg.setField(14, std::to_string(report->filledQuantity));     // CumQty
    
    // Ë®≠ÂÆöÂÉπÊ†ºÊ¨Ñ‰Ωç
    if (report->price > 0.0) {
        std::ostringstream priceStr;
        priceStr << std::fixed << std::setprecision(2) << report->price;
        fixMsg.setField(44, priceStr.str());                  // Price
    }
    
    // Â¶ÇÊûúÊúâÊàê‰∫§ÔºåË®≠ÂÆöÊàê‰∫§Ë≥áË®ä
    if (report->executionQuantity > 0) {
        fixMsg.setField(32, std::to_string(report->executionQuantity)); // LastQty
        
        if (report->executionPrice > 0.0) {
            std::ostringstream execPriceStr;
            execPriceStr << std::fixed << std::setprecision(2) << report->executionPrice;
            fixMsg.setField(31, execPriceStr.str());          // LastPx
        }
    }
    
    // Â¶ÇÊûúÊúâÊãíÁµïÂéüÂõ†ÔºåË®≠ÂÆö Text Ê¨Ñ‰Ωç
    if (!report->rejectReason.empty()) {
        fixMsg.setField(58, report->rejectReason);            // Text
    }
    
    // Ë®≠ÂÆöÊôÇÈñìÊ¨Ñ‰Ωç
    fixMsg.setField(60, formatCurrentTime());                // TransactTime
    
    return fixMsg;
}

// ===== ÁôºÈÄÅÊñπÊ≥ï =====

bool TradingSystem::sendFixMessage(SOCKET clientSocket, const FixMessage& fixMsg) {
    try {
        std::string serialized = fixMsg.serialize();
        std::cout << "üì§ Sending FIX message to client " << clientSocket << ": " << serialized << std::endl;
        
        return tcpServer_->sendMessage(static_cast<SOCKET>(clientSocket), serialized);
        
    } catch (const std::exception& e) {
        std::cerr << "Error sending FIX message: " << e.what() << std::endl;
        return false;
    }
}

void TradingSystem::sendOrderReject(SOCKET clientSocket, const FixMessage& originalMsg, const std::string& reason) {
    try {
        std::cout << "‚ùå Sending Order Reject to client " << clientSocket << ": " << reason << std::endl;
        
        // Âª∫Á´ã ExecutionReport Ë°®Á§∫ÊãíÁµï
        FixMessage rejectMsg('8');  // ExecutionReport
        
        // Ë§áË£ΩÂéüÂßãË®äÊÅØÁöÑÈóúÈçµÊ¨Ñ‰Ωç
        rejectMsg.setField(11, originalMsg.getField(11));     // ClOrdID
        rejectMsg.setField(55, originalMsg.getField(55));     // Symbol
        rejectMsg.setField(54, originalMsg.getField(54));     // Side
        rejectMsg.setField(38, originalMsg.getField(38));     // OrderQty
        
        // Ë®≠ÂÆöÊãíÁµïÁãÄÊÖã
        rejectMsg.setField(17, generateExecId());             // ExecID
        rejectMsg.setField(150, "8");                         // ExecType = Rejected
        rejectMsg.setField(39, "8");                          // OrdStatus = Rejected
        rejectMsg.setField(151, "0");                         // LeavesQty = 0
        rejectMsg.setField(14, "0");                          // CumQty = 0
        rejectMsg.setField(58, reason);                       // Text (ÊãíÁµïÂéüÂõ†)
        rejectMsg.setField(60, formatCurrentTime());          // TransactTime
        
        sendFixMessage(clientSocket, rejectMsg);
        
    } catch (const std::exception& e) {
        std::cerr << "Error sending order reject: " << e.what() << std::endl;
    }
}

// ===== Â∑•ÂÖ∑ÊñπÊ≥ï =====

std::string TradingSystem::generateExecId() {
    uint64_t execNum = nextExecId_.fetch_add(1);
    auto now = std::chrono::system_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()).count();
    
    std::ostringstream oss;
    oss << "EXEC_" << timestamp << "_" << execNum;
    return oss.str();
}

char TradingSystem::getFixExecType(OrderStatus status) {
    switch (status) {
        case OrderStatus::New: return '0';
        case OrderStatus::PartiallyFilled: return '1';
        case OrderStatus::Filled: return '2';
        case OrderStatus::Cancelled: return '4';
        case OrderStatus::Rejected: return '8';
        default: return '0';
    }
}

char TradingSystem::getFixOrdStatus(OrderStatus status) {
    switch (status) {
        case OrderStatus::New: return '0';
        case OrderStatus::PartiallyFilled: return '1';
        case OrderStatus::Filled: return '2';
        case OrderStatus::Cancelled: return '4';
        case OrderStatus::Rejected: return '8';
        default: return '0';
    }
}

// ===== Ê∏ÖÁêÜÊñπÊ≥ï =====

void TradingSystem::cleanupSession(SOCKET clientSocket) {
    std::lock_guard<std::mutex> lock(sessionsMutex_);
    sessions_.erase(clientSocket);
}

void TradingSystem::cleanupResources() {
    {
        std::lock_guard<std::mutex> lock(sessionsMutex_);
        sessions_.clear();
    }
    
    {
        std::lock_guard<std::mutex> lock(mappingsMutex_);
        orderMappings_.clear();
    }
}

// ===== Áµ±Ë®àË≥áË®ä =====

void TradingSystem::printStatistics() {
    std::cout << "\nüìä Trading System Statistics:" << std::endl;
    std::cout << "================================" << std::endl;
    
    if (matchingEngine_) {
        std::cout << matchingEngine_->getStatistics().toString() << std::endl;
    }
    
    {
        std::lock_guard<std::mutex> lock(sessionsMutex_);
        std::cout << "Active Sessions: " << sessions_.size() << std::endl;
    }
    
    {
        std::lock_guard<std::mutex> lock(mappingsMutex_);
        std::cout << "Pending Orders: " << orderMappings_.size() << std::endl;
    }
    
    std::cout << "================================\n" << std::endl;
}

// ===== Â∑•ÂÖ∑ÂáΩÂºè =====

Side parseFixSide(const std::string& sideStr) {
    if (sideStr == "1") return Side::Buy;
    if (sideStr == "2") return Side::Sell;
    throw std::invalid_argument("Invalid FIX side: " + sideStr);
}

OrderType parseFixOrderType(const std::string& typeStr) {
    if (typeStr == "1") return OrderType::Market;
    if (typeStr == "2") return OrderType::Limit;
    if (typeStr == "3") return OrderType::Stop;
    if (typeStr == "4") return OrderType::StopLimit;
    throw std::invalid_argument("Invalid FIX order type: " + typeStr);
}

std::string formatCurrentTime() {
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    
    std::ostringstream oss;
    oss << std::put_time(std::gmtime(&time_t), "%Y%m%d-%H:%M:%S");
    return oss.str();
}