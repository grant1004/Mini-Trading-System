# Mini Trading System (MTS)

## 🎯 專案動機與背景

為了深入理解金融科技領域的核心技術，我決定構建一個完整的交易系統。

這個專案展示我對**高頻交易系統設計思維**、**金融業務邏輯**和**C++ 高性能程式設計**的學習成果。

## 🏗️ 技術棧與架構選擇

### **核心技術棧**
- **C++17/20**：現代 C++ 特性，RAII、智能指標、原子操作
- **多執行緒程式設計**：std::thread、std::mutex、std::atomic、condition_variable
- **網路程式設計**：Windows Socket → 未來遷移至 Boost.Asio
- **協議實作**：FIX 4.4 金融資訊交換協議
- **測試框架**：Google Test 單元測試、整合測試、效能測試
- **建置系統**：CMake + vcpkg 現代化依賴管理

### **系統架構設計**
```
分層架構設計
├── 網路層 (Network Layer)     - TCP 多客戶端處理 (TCP server) 
├── 協議層 (Protocol Layer)    - FIX 4.4 訊息解析與驗證 (Fix message)
├── 應用層 (Application Layer) - 業務邏輯整合與路由 (Trading System)  
├── 撮合引擎 (Matching Engine) - 價格-時間優先撮合
└── 資料層 (Data Layer)        - 訂單簿與市場資料管理(Order, OrderBook)
```

## 📚 深度學習成果

### **金融交易系統核心概念**

#### **FIX 協議深度理解**
- **訊息結構**：BeginString、BodyLength、MsgType、CheckSum 的作用
- **業務訊息**：NewOrderSingle (35=D)、ExecutionReport (35=8)、OrderCancelRequest (35=F)
- **會話管理**：Logon/Logout 流程、心跳機制、序列號管理
- **錯誤處理**：Reject 訊息、重送機制、會話恢復

#### **撮合引擎核心邏輯**
- **價格-時間優先原則**：全球交易所通用的撮合演算法
- **訂單生命週期**：New → PartiallyFilled → Filled 的狀態轉換
- **市場資料生成**：Best Bid/Ask、市場深度、成交資訊
- **風險管理**：價格檢查、數量限制、符號驗證

#### **訂單類型與業務邏輯**
- **限價單 (Limit Order)**：指定價格的掛單機制
- **市價單 (Market Order)**：立即以最佳價格成交
- **停損單 (Stop Order)**：條件觸發的風險控制
- **時效性管理**：Day、GTC、IOC、FOK 的實作差異

### **C++ 高性能程式設計精進**

#### **多執行緒並發設計**
```cpp
// 執行緒安全的併發處理
class MatchingEngine {
    std::atomic<bool> running_{false};                    // 原子狀態管理
    std::mutex messageQueueMutex_;                        // 互斥鎖保護共享資源
    std::condition_variable messageQueueCV_;              // 條件變數實現等待/通知
    std::queue<InternalMessagePtr> incomingMessages_;     // 執行緒間訊息傳遞
    
    void processingLoop();  // 專用執行緒處理撮合邏輯
};
```

#### **記憶體管理與效能優化**
- **智能指標應用**：std::shared_ptr、std::unique_ptr 自動資源管理
- **移動語意**：std::move 減少不必要的拷貝開銷
- **RAII 原則**：資源取得即初始化，確保資源正確釋放
- **原子操作**：std::atomic 實現無鎖併發，提升效能

#### **現代 C++ 特性運用**
- **Lambda 表達式**：回調函式的優雅實作
- **auto 類型推導**：提升程式碼可讀性
- **range-based for**：現代化的迭代器使用
- **constexpr**：編譯期常數優化

#### **測試驅動開發**
```cpp
// Google Test 完整測試覆蓋
TEST_F(OrderBookTest, BasicMatching) {
    // 單元測試：驗證撮合邏輯正確性
}

TEST_F(FixMessageTest, SerializationRoundTrip) {
    // 協議測試：確保訊息解析的正確性
}
```

### **系統設計與架構思維**

#### **事件驅動架構**
- **回調機制**：std::function 實現組件間解耦
- **訊息佇列**：異步處理提升系統響應性
- **觀察者模式**：執行報告與市場資料的事件分發

#### **分層設計原則**
- **單一職責**：每個類別專注於特定功能
- **依賴注入**：介面抽象化，提升可測試性
- **模組化設計**：組件可獨立開發、測試、部署

#### **併發與同步**
- **執行緒池模式**：每客戶端獨立執行緒處理
- **生產者-消費者模式**：撮合引擎的訊息處理機制
- **讀寫分離**：市場資料查詢與訂單處理分離

## 🎖️ 專案成果與價值

### **技術深度展示**
- **完整的端到端實作**：從 TCP 連線到業務邏輯的全棧開發
- **企業級程式碼品質**：完整的測試覆蓋、錯誤處理、資源管理
- **效能意識**：微秒級延遲測量、吞吐量統計、記憶體優化

### **業務理解展現**
- **金融協議精通**：FIX 4.4 標準的深度實作
- **交易邏輯掌握**：撮合演算法、風險管理、市場資料處理
- **系統思維**：可擴展性、高可用性、監控機制的設計考量

### **工程實踐能力**
- **現代化開發流程**：Git 版本控制、CMake 建置、自動化測試

## 🚀 與真實交易所的對標

雖然在**規模**和**效能**上與生產級交易所存在差距，但在**核心概念**和**設計思維**上保持一致：

| 概念領域 | MTS 實作 | 交易所標準 | 一致性 |
|---------|---------|-----------|--------|
| **協議處理** | FIX 4.4 完整實作 | FIX 4.4 標準 | ✅ 完全一致 |
| **撮合演算法** | 價格-時間優先 | 全球標準演算法 | ✅ 邏輯相同 |
| **訂單管理** | 完整生命週期 | 標準狀態機 | ✅ 流程一致 |
| **架構設計** | 分層事件驅動 | 企業級架構 | ✅ 模式相同 |
| **併發處理** | 多執行緒安全 | 高併發設計 | ✅ 原則相同 |
